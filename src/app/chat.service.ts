import { Injectable, Inject } from '@angular/core';
import { ChatLine } from './chatline';
import { MessageService } from './message.service';

// Firebase
import { initializeApp, database } from 'firebase';
import { AngularFireDatabase, AngularFireList } from 'angularfire2/database'; // AngularFire, FirebvaseListObservable

// Used for Http Requests
import { Observable } from 'rxjs/Observable'; // Class from RxJS library
import { of } from 'rxjs/observable/of';
import { Http, Headers, Request } from '@angular/http';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { catchError, map, tap } from 'rxjs/operators';

/*
	Service that deals with chat-related functionality such as obtaining messages from the server
	and adding messages to the server
*/
@Injectable()
export class ChatService {

	username: string;
	private chatlog;
	
	constructor(private messageService: MessageService,
				private http: HttpClient,
				private af: AngularFireDatabase) { 
		
		this.initFirebaseDatabase();
				
	}
	/** Initializes Firebase synchronization with the database */
	initFirebaseDatabase(): void {
		this.chatlog = this.af.list('chatlog').valueChanges();
		// valueChanges() - Returns and Observable of data as a synchronized array of JSON objects.
		// 		All Snapshot metadata is stripped and just the method provides only the data.
		// 		Use for just needing a list of data.
		//		Do not use when you need a more complex data structure than an array
		
		// snapshotChanges() - Returns an Observable of data as a synchronized array of AngularFireAction<DatabaseSnapshot>[].
		//		Use when you need a list of a data but also want to keep around metadata.
		//			Provides DatabaseReference and snapshot key.  Key makes it eaier to use data manipulation methods
		//				Method controlled by type property.  type property on each AngularFireAction is useful for ngrx reducers, form states, and animation states
		//		Do not use when you need a more complex data than an array 
	}
	
	/** Returns chatlog observable */
	getChatLog() : Observable<any> {
		return this.chatlog;
	}
	
	/** Pushes new message to server.  Unique ID is generated by the server */
	pushMessage(u: string, c: string) : void {
		let itemsRef = this.af.list('chatlog');
		itemsRef.push({ username: u, content: c });
	}

	/**	Logs the user into the chatroom */
	setUsername(name: string): void {
		this.username = name;
		this.log('Username \'' + this.username + '\': logged in');
	}
	
	/** Returns the username and emits a broadcast to the socket server */
	getUsername(): string {
		this.log('Username \'' + this.username + '\':  registered in chat');
		return this.username;
		
	}
	clearAllMessages(): void {
		let itemsRef = this.af.list('chatlog');
		itemsRef.remove();
		
	}
	/**
	* Handle Http operation that failed.
	* Let the app continue.
	* @param operation - name of the operation that failed
	* @param result - optional value to return as the observable result
	*/
	private handleError<T> (operation = 'operation', result?: T) {
		return (error: any): Observable<T> => {
	 
			// TODO: send the error to remote logging infrastructure
			console.error(error); // log to console instead
		 
			// TODO: better job of transforming error for user consumption
			this.log(`${operation} failed: ${error.message}`);
		 
			// Let the app keep running by returning an empty result.
			return of(result as T);
		};
	}
	/** Log a HeroService message with the MessageService */
	private log(message: string) {
		this.messageService.add('ChatService: ' + message);
	}
	

	
}
